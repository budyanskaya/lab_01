# Лабораторная работа 01. Реализация RPC-сервиса с использованием gRPC
## Цель работы:
* освоить принципы удаленного вызова процедур (RPC) и их применение в распределенных системах;
* изучить основы фреймворка gRPC и языка определения интерфейсов Protocol Buffers (Protobuf);
* научиться определять сервисы и сообщения с помощью Protobuf;
* реализовать клиент-серверное приложение на языке Python с использованием gRPC;
* получить практические навыки в генерации кода, реализации серверной логики и клиентских вызовов для различных типов RPC.
## Вариант 3
## Предметная область
Логистика
## Описание сервиса и его методов
Сервис InventoryControl: метод BulkUpdateStock(stream StockItem) для массового обновления остатков на складе (Client streaming RPC).
## Архитектура
В основе лабораторной работы лежит классическая клиент-серверная архитектура (Client-Server Architecture), реализованная с помощью парадигмы удалённого вызова процедур (Remote Procedure Call — RPC).
## 1. Компоненты
## Сервер (Server)
Независимое приложение server.py, которое выполняет основную бизнес-логику.

Возможности:
 * Предоставляет сервис. Реализует и «выставляет наружу» сервис LogisticsService, определённый в контракте.
 * Обрабатывает запросы. Слушает входящие сетевые соединения на заданном порту (например, 50051) и принимает вызовы от клиентов.
 * Выполняет логику. Обрабатывает поток данных о поставках и перемещениях товаров, актуализируя информацию о доставках, маршрутах и складах.
 * Асинхронность. Использует пул потоков (futures.ThreadPoolExecutor) для одновременной обработки множества клиентских запросов и потоковых обновлений.

## Клиент (Client)
Приложение client.py, которое потребляет функциональность, предоставляемую сервером.

Возможности:
 * Инициирует соединение. Устанавливает соединение с сервером по известному адресу (localhost:50051).
 * Вызывает удалённые методы. Обращается к методам сервера так, как будто это локальные функции.
 * Передаёт поток данных. Отправляет последовательность объектов StockItem в рамках клиентского стриминга для массового обновления остатков на складах.
 * Обрабатывает ответы. Получает подтверждение от сервера о результатах обработки каждого элемента потока и итоговое сообщение об успешном завершении.

## 2. Взаимодействие и Контракт
Ключевым элементом архитектуры является сервисный контракт (Service Contract), определённый в файле logistics.proto.

Роль контракта:
Этот файл является «единым источником правды» для API. Он строго описывает:
 * Доступные сервисы. Например, LogisticsService.
 * Методы сервиса. Основной метод — BulkUpdateStock(stream StockItem), предназначенный для массового обновления остатков на складе (Client-streaming RPC).
 * Структуры данных. Определяет сообщения StockItem (содержит идентификатор товара, склад, количество) и UpdateResponse (подтверждение или описание ошибок).
## Технологический стек
1. Язык определения интерфейсов (IDL): Protocol Buffers (Protobuf)
2. Фреймворк RPC: gRPC
3. Транспортный протокол: HTTP/2
4. Язык программирования: Python 3
5. Ключевые библиотеки Python:
   
a) grpcio

b) grpcio-tools

6. Среда выполнения и изоляция:
   
a) ОС: Ubuntu 20.04 (Linux).

b) Виртуальное окружение (venv). Инструмент для изоляции зависимостей
проекта, гарантирующий, что установленные пакеты (grpcio и др.) не будут
конфликтовать с системными или другими проектами.
## Шаг 1. Подготовка окружения
Предварительно создаю новую папку, открываю ее в вижуал студио, после чего обновляю пакеты, устанавливаю Python, а также создаю и активирую виртуальное окружение.
Обновляем пакеты:
```
sudo apt update
```
Устанавливаем Python:
```
sudo apt install python3 python3-pip python3-venv -y
```

<img width="681" height="435" alt="image" src="https://github.com/user-attachments/assets/cd6c2900-5594-4d57-b92d-6b8f6333f2b2" />
<img width="675" height="358" alt="image" src="https://github.com/user-attachments/assets/a6cf9b22-c052-4500-949e-e8b9dc56d6b4" />


Создание виртуального окружения:
```
mkdir grpc_logistic_lab
cd grpc_logistic_lab
python3 -m venv venv
source venv/bin/activate
```

<img width="533" height="102" alt="image" src="https://github.com/user-attachments/assets/4f4a01f3-0f7e-4d42-ad77-7fa077fa63e2" />

Установка библиотеки gRPC:
```
pip install grpcio grpcio-tools
```

<img width="643" height="311" alt="image" src="https://github.com/user-attachments/assets/b07f7298-29c1-4099-8054-1a1629f6bd89" />

После выполненых действий, получили следующий результат:

<img width="198" height="280" alt="image" src="https://github.com/user-attachments/assets/e3739d25-df35-485b-a595-7067ef4fca43" />

## Шаг 2. Создание файлов inventory.proto, server.py, client.py
Создаю файлы нужного вида и заполняю их:

<img width="812" height="608" alt="image" src="https://github.com/user-attachments/assets/9355b38f-85c7-4043-b7c4-7eb9a284b232" />
<img width="805" height="597" alt="image" src="https://github.com/user-attachments/assets/7e2dc37a-4a04-4a17-92ad-c6353ca538d2" />
<img width="808" height="602" alt="image" src="https://github.com/user-attachments/assets/7db69670-dacb-446b-a23d-4aa6fd0fef4a" />

## Шаг 3. Генерация кода:
Выполняю следующую команду:
```
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. inventory.proto
```
При этом создаются файлы `inventory_pb2.py` и `inventory_pb2_grpc.py`, которые содержат сгенерированные классы для клиента и сервера.

<img width="158" height="45" alt="image" src="https://github.com/user-attachments/assets/3c138241-4c43-4ba8-bf59-8cd233947a1f" />

## Шаг 4. Запуск и проверка:
Для этого открываю двойной терминал, и там и там активируем окружение, затем на одном запускаем клиентский файл, а на другом серверный файл и выполняем следующие команды:
```
cd grpc_logistic_lab
source venv/bin/activate
```
```
python serser.py
```
```
python client.py
```
Все успешно выполнилось:

<img width="805" height="597" alt="image" src="https://github.com/user-attachments/assets/9d1259fd-3a3d-49dc-952b-3db27e264697" />

## Вывод:
В ходе работы мы  освоили принципы удаленного вызова процедур (RPC) и их применение в распределенных системах, изучили основы фреймворка gRPC и языка определения интерфейсов Protocol Buffers (Protobuf), научились определять сервисы и сообщения с помощью Protobuf, смогли реализовать клиент-серверное приложение на языке Python с использованием gRPC, а также получили практические навыки в генерации кода, реализации серверной логики и клиентских вызовов для различных типов RPC.


